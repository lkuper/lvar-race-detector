{-# LANGUAGE CPP #-}
{-# LANGUAGE TemplateHaskell #-}

{-# OPTIONS_GHC -fwarn-incomplete-patterns #-}

-- Perform a simple test of the unique-desugaring transformation in
-- figure 10 of this paper:
--   http://www.cs.indiana.edu/~rrnewton/papers/2012-lambdapar-draft.pdf

module Language.LambdaLVar.UniqueDesugar where

import Algebra.Lattice (BoundedJoinSemiLattice)
import Language.LambdaLVar.Common
import Language.LambdaLVar.Eval4 (evalThreaded)
import Language.LambdaLVar.Eval1 
import Text.PrettyPrint.GenericPretty (Out(..), doc)
import Data.Set as S

import System.IO (stderr, stdout, hPutStrLn)
import System.IO.Unsafe (unsafePerformIO)
import Test.Framework.TH (testGroupGenerator, defaultMainGenerator)
import Test.HUnit
import Test.Framework.Providers.HUnit

x = var "x"
y = var "y"
z = var "z"
p = var "p"
p_ = var "ignored"
loc = var "loc"
loc2 = var "loc2"

ig1 = var "ignr1"
ig2 = var "ignr2"

----------------------------------------------------------------------------------------------------

-- | The desugaring pass that removes the 'unique' form.
desugar e = 
  case e of         
    Unique   ->  Lam p (Varref p)
    
    Varref v -> Lam p_ $ Varref v
    Q set    -> Lam p_ $ Q set
    Num n    -> Lam p_ $ Num n
    New      -> Lam p_ $ New  
    
    App e1 e2 -> Lam p $ 
                 (App (App (App (desugar e1) (consL$ Varref p))
                           (App (desugar e2) (consR$ Varref p)))
                      (consJ$ Varref p))
    Lam v e -> Lam p $ Lam v $ desugar e


    -- Hack for demonstration purposes, reify pedigree:
    -- Put e1 _e2 -> Lam p $ Put (App (desugar e1) (Varref p)) (Varref p)

    Put e1 e2 -> Lam p $ 
                 (Put (App (desugar e1) (consL$ Varref p))
                      (App (desugar e2) (consR$ Varref p)))
    Get e1 e2 -> Lam p $ 
                 (Get (App (desugar e1) (consL$ Varref p))
                      (App (desugar e2) (consR$ Varref p)))
    
    PrimApp prm e1 e2 -> Lam p $
                 (PrimApp prm (App (desugar e1) (consL$ Varref p))
                              (App (desugar e2) (consR$ Varref p)))

    Consume e -> Lam p $ Consume $ App (desugar e) (Varref p)
    Reify  e -> Lam p $ Reify  $ App (desugar e) (Varref p)

 where  
   -- Fake operations on pedigree trees:
   consL = App (Varref (var "consL")) -- These are NOT normal desugared varrefs
   consR = App (Varref (var "consR"))
   consJ = App (Varref (var "consJ"))


--------------------------------------------------------------
-- Wrappers / evaluators for programs generated by desugaring:

-- OPTION 1: Do NOTHING to track pedigree.
-- Takes an ALREADY DESUGARED input:
runDesugNopPed prog = 
      eval 
      (lett [ (var "consL", Lam p_ $ Lam x $ Lam p (Varref x))
            , (var "consR", Lam p_ $ Lam x $ Lam p (Varref x))
            , (var "consJ", Lam p_ $ Lam x $ Lam p (Varref x))] 
       (App prog initP))
      exampleReify
 where initP = void

-- OPTION 2: Use stateful locations to model pedigree.  Requires a specific domain.
-- Takes an ALREADY DESUGARED input:
runDesugLocPed :: Exp LRJ -> (Exp LRJ, SymbolMap LRJ)
runDesugLocPed prog = 
      eval 
--      evalThreaded  
      (lett [ (loc, New) ] $ 
       -- The idea here is to represent paths as locations, and use a
       -- CHEATING non-commutative LUB to add info to those locations.
       lett [ (var "consL", cons 1)
            , (var "consR", cons 2)
            , (var "consJ", cons 3)]
       (App prog initP))
      exampleReify
 where 
   initP = New   
   -- Note: The representation of pedigres is as RAW values (without \p's)
   cons n = Lam loc $ 
            -- Create a string locations, one for each cons:
            lett [(loc2, New),
                  (x,    Get (Varref loc) anyQ),
                  (ig1,  Put (Varref loc2) (Varref x)),
                  (ig2,  Put (Varref loc2) (Q$ QS (S.singleton (LRJ n))))
                 ]
            (Varref loc2)

-- OPTION 3: Use integers to encode paths.  This is similar to the
-- previous encoding but better because it doesn't pollute the domain.
runDesugNumPed :: (Eq d, Out d, Show d, BoundedJoinSemiLattice d) 
               =>  Exp d -> (Exp d, SymbolMap d)
runDesugNumPed prog = 
      eval 
--      evalThreaded  
      (lett [ (var "consL", cons 1)
            , (var "consR", cons 2)
            , (var "consJ", cons 3)]
       (App prog initP))
      exampleReify
 where 
   initP = Num 0
   cons n = Lam p $ PrimApp Add  (Num n)  $ 
                    PrimApp Mult (Num 10) $ 
                    Varref p

----------------------------------------------------------------------------------------------------
-- Define Unit tests
----------------------------------------------------------------------------------------------------

ident = (Lam x (Varref x))

p1 :: Exp (LRJ)
p1 = Unique

-- Right pedigree:
p1b :: Exp (LRJ)
p1b = App ident Unique

-- Post-join pedigree:
p1c :: Exp (IVar ())
p1c = App (Lam x Unique) (Num 9)

-- Go a little deeper: Left then Right:
p1d :: Exp (IVar ())
p1d = App (App f Unique) Unique
 where f = Lam x$ Lam y$ Varref x
    
------------------------------

p2 :: Exp LRJ
p2 = App ident void

-- Do a get with a query function (oracle):
p3a :: Exp (IVar Integer)
p3a = lett [ (x, New)
          , (y, put x (singQ (Full 33)))] $ 
     get x (Q(QF fn))
 where fn Empty = Nothing
       fn x     = Just x -- CHEATING, return the raw state directly.

-- Next do the same thing, but in parallel:
p3b :: Exp (IVar Int)
p3b = lett   [ (x, New) ]$ 
      letpar [ (y, put x (singQ (Full 33)))
             , (z, get x (Q(QF fn)))]
      (Varref z)
 where fn Empty = Nothing
       fn x     = Just x -- CHEATING, return the raw state directly.

-- | Erroneous version, block forever:
p3Err :: Exp (IVar Int)
p3Err = lett   [ (x, New) ]$ 
        letpar [ (z, get x (Q(QF fn)))]
        (Varref z)
 where fn Empty = Nothing
       fn x     = Just x -- CHEATING, return the raw state directly.

--------------------
-- Next test Arithmetic

p4 :: Exp LRJ
p4 = PrimApp Add (Num 4) (Num 3)

--------------------
-- Next test a DATA RACE:

-- This one has a race:
p5a :: Exp (IVar Int)
p5a = lett   [ (x, New) ]$ 
      letpar [ (y, put x (singQ (Full 33)))
             , (z, Consume (Varref x)) ]
      (Varref z)

-- This one doesn't:
p5b :: Exp (IVar Int)
p5b = lett  [ (x, New)
            , (y, put x (singQ (Full 33))) ]
      (Consume (Varref x))

--------------------

omega :: Exp (IVar ())
omega = App f f 
 where f = Lam x (App (Varref x) (Varref x))

t6 = eval omega exampleReify

d6 = desugar omega

td6 = runDesugNopPed d6

--------------------

p7 :: Exp (IVar String)
p7 = lett [(y, New)] $ 
     App ident (Put (Varref y) (Q$ QS$ S.singleton$ Full "hi"))

t7 = eval p7 exampleReify
d7 = desugar p7
-- td7 = runDesugLocPed d7

--------------------------------------------------------------------------------
--  Run Unit Tests
--------------------------------------------------------------------------------

-- port = stderr
port = stdout


testOne prog evalFn = unsafePerformIO$ do
    hPutStrLn port$ "\nDesugaring the following test program:"
    hPutStrLn port "================================================================================"
    hPutStrLn port ("   "++ show prog)
    hPutStrLn port "================================================================================"
    let desug = desugar prog
    hPutStrLn port$ "Desugared: \n  " ++ show (doc desug)
    hPutStrLn port "--------------------------------------------------------------------------------"    
    let (e1,s1) = eval prog exampleReify
--    hPutStrLn port$ "Now running original (pre-desugured) version:"            
--    hPutStrLn port$ show $ doc e1
        
    hPutStrLn port$ "Now running desugured version:"                            
    let (e2,s2) = evalFn desug 
    hPutStrLn port$ show $ doc e2
    
    return (e2,s2)


case_old_up1  = (Varref (var "l1"))        @=? fst (testOne p1  runDesugLocPed)
case_old_up1b = (Varref (var "l3"))        @=? fst (testOne p1b runDesugLocPed)
case_up1      = (Num 0)                    @=? fst (testOne p1  runDesugNumPed) -- [], root Pedigree
case_up1b     = (Num 2)                    @=? fst (testOne p1b runDesugNumPed) -- [Right]
case_up1c     = (Num 3)                    @=? fst (testOne p1c runDesugNumPed) -- [Join]
case_up1d     = (Num 12)                   @=? fst (testOne p1d runDesugNumPed) -- [Right, Left]

case_up2  =  Q (QS (S.fromList []))        @=? fst (testOne p2  runDesugNopPed)
case_up3a =  Q (QS (S.fromList [Full 33])) @=? fst (testOne p3a runDesugNopPed)
case_up3b =  Q (QS (S.fromList [Full 33])) @=? fst (testOne p3b runDesugNopPed)
case_up4  =  Num 7                         @=? fst (testOne p4  runDesugNopPed)

------------------------------------------------------------
runTests = $(defaultMainGenerator)

uniqueTests = $(testGroupGenerator)
